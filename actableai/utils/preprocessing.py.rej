diff a/actableai/utils/preprocessing.py b/actableai/utils/preprocessing.py	(rejected hunks)
@@ -13,7 +16,29 @@ def impute_df(df, numeric_imputer=None, categorical_imputer=None):
     if len(categorical_cols) > 0:
         df[categorical_cols] = categorical_imputer.fit_transform(df[categorical_cols])
 
-from sklearn.base import BaseEstimator, TransformerMixin, _OneToOneFeatureMixin
+class TimeZoneTransformer(TransformerMixin, BaseEstimator):
+    def fit(self, X):
+        return self
+
+    def transform(self, X):
+        self.result = X.apply(lambda x : x.dt.tz_convert(None))
+        return self.result
+
+    def fit_transform(self, X, y=None, **fit_params):
+        return self.transform(X)
+
+    def get_feature_names(self):
+        return self.result.columns
+
+class CopyTransformer(TransformerMixin, BaseEstimator):
+    def fit(self, X):
+        return self
+
+    def transform(self, X, y=None):
+        return X.copy()
+
+    def fit_transform(self, X, y=None, **fit_params):
+        return self.transform(X, y)
 
 class PercentageTransformer(_OneToOneFeatureMixin, BaseEstimator, TransformerMixin):
     """Percentage Transformer that transforms strings with percentages into floats
@@ -37,3 +62,36 @@ class PercentageTransformer(_OneToOneFeatureMixin, BaseEstimator, TransformerMix
         parsed_rate_check = lambda x, min : x.isna().sum() >= min * len(x)
         extracted = df[obj_cols].apply(lambda x: x.str.extract(r'^[^\S\r\n]*(\d+(?:\.\d+)?)[^\S\r\n]*%[^\S\r\n]*$')[0])
         return ~extracted.apply(lambda x: parsed_rate_check(x, 0.5))
+
+class SKLearnAGFeatureWrapperBase(TransformerMixin, BaseEstimator):
+    """SKLearn Transformer Wrapper around AutoGluonFeature Generator
+
+    Args:
+        TransformerMixin (_type_): _description_
+        BaseEstimator (_type_): _description_
+    """
+    def __init__(self, ag_feature_generator) -> None:
+        """Init class
+
+        Args:
+            ag_feature_generator (AbstractFeatureGenerator): AutoGluon Feature Generator
+        """
+        super().__init__()
+        self.ag_feature_generator = ag_feature_generator
+        self.transformed_df=None
+
+    def fit(self, X, **kwargs):
+        return self.ag_feature_generator.fit(X)
+
+    def fit_transform(self, X, y=None, **fit_params):
+        self.transformed_df = self.ag_feature_generator.fit_transform(X)
+        return self.transformed_df
+
+    def transform(self, X, y=None):
+        self.transformed_df = self.ag_feature_generator.transform(X)
+        return self.transformed_df
+
+    def get_feature_names_out(self, input_features=None):
+        if self.transformed_df is None:
+            raise Exception("Needs to be fit_transform first")
+        return list(self.transformed_df.columns)
